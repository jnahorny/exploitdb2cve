#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import re
import argparse
import json
import datetime
import pygit2
from pathlib import Path
from typing import List, Dict


def is_repo(edb: Path) -> bool:
    """
    :param edb: path to directory to verify
    :return: is it a valid git repo?
    """
    try:
        pygit2.Repository(edb)
        print(f"[*] Looks like {edb} is a git repo, but make sure it's up to date yourself.")
        return True
    except pygit2.GitError as err:
        print("[!]", err)
        return False


def clone_exploitdb(edb: Path) -> None:
    """
    :param edb: where to clone the repo
    :return: None
    """
    try:
        remote_uri = "https://gitlab.com/exploit-database/exploitdb.git"
        print(f"[*] Trying to clone into {edb}")
        pygit2.clone_repository(remote_uri, edb)
    except ValueError as err:
        print("[!]", err)
        sys.exit(1)


def unique_cves_from_file(file_path: Path) -> List[str]:
    """
    Get a list of all unique strings matching a CVE format in a given file

    :param file_path: file to parse
    :return: list of CVE numbers
    """
    try:
        exploit_file_contents = file_path.read_text(encoding="utf-8")
    except IOError as err:
        print("[!] skipping fileâ€¦", err)
        return []
    regex = r"CVE-\d{4}-\d{4,}"
    # quick way to keep it as a list, but make unique
    return list(set(re.compile(regex).findall(exploit_file_contents)))


def get_mapping(edb: Path) -> Dict[str, List[str]]:
    """
    Create a mapping: EDBID -> CVEs

    :param edb: path to directory with cloned exploitdb repo
    :return: a mapping (list of dictionaries)
    """
    files_exploits = Path(edb, "files_exploits.csv")
    if not files_exploits.exists():
        sys.exit("[!] The file 'files_exploits.csv' not found in the specified directory.")
    e2c = {}
    # loop through the file, grab the EDBID, parse the target file, and find CVEs in it.
    with open(files_exploits, mode="r", encoding="utf-8") as fe:
        for line in fe.readlines():
            # don't parse header (1st line)
            if not re.compile(r"id,file,description,date,author,type,platform,port").match(line):
                # file format is:
                # id,file,description,date,author,type,platform,port
                # but we just need first 2 columns
                edb_id, exploit_file, _ = line.split(",", maxsplit=2)
                cves: List[str] = unique_cves_from_file(Path(edb, exploit_file))
                if len(cves) > 0:
                    e2c[edb_id] = cves
    return e2c


def get_reverse_mapping(e2c: Dict[str, List[str]]) -> Dict[str, List[str]]:
    c2e = {}
    for k in e2c:
        for v in e2c[k]:
            c2e.setdefault(v, []).append(k)
    return c2e


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate mapping: EDBID => CVEs")
    parser.add_argument("exploit_db_path", help="ExploitDB repo path (will clone, if doesn't exist)")
    parser.add_argument("-r", "--reverse", help="Produce reverse mapping (cve -> edbid(s)",
                        action="store_true")
    parser.add_argument("-o", "--output", action="store", dest="output",
                        default="./artifacts/mapping.json", help="(json) output file path")
    args = parser.parse_args()

    edb_path = Path(args.exploit_db_path)
    if not is_repo(edb_path):
        clone_exploitdb(edb_path)

    mapping = get_mapping(edb_path)
    if args.reverse:
        mapping = get_reverse_mapping(mapping)

    now = datetime.datetime.utcnow().isoformat(timespec='seconds')
    doc = {"timestamp": now, "mapping": mapping}
    with open(args.output, "w") as o:
        json.dump(doc, o)
    print(f"[*] Mapping written successfully into {args.output}")
